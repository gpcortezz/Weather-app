<meta charset="UTF-8">
<h2>8.1. Flujos de Trabajo Importantes</h2>

<h3>Weather Data Fetching</h3>
<p><strong>Propósito:</strong> Obtener datos meteorológicos actualizados desde APIs externas</p>
<p><strong>Pasos del flujo:</strong></p>
<ol>
    <li><strong>Iniciación:</strong> Usuario accede a la aplicación o actualiza manualmente</li>
    <li><strong>Obtención de ubicación:</strong> Se utiliza la Geolocation API del navegador</li>
    <li><strong>Validación de permisos:</strong> Verificar que el usuario ha concedido permisos de ubicación</li>
    <li><strong>Construcción de URL:</strong> Formatear la URL de la API con coordenadas y API key</li>
    <li><strong>Llamada a API externa:</strong> Usar Fetch API para obtener datos meteorológicos</li>
    <li><strong>Procesamiento de respuesta:</strong> Parsear JSON y extraer datos relevantes</li>
    <li><strong>Almacenamiento en caché:</strong> Guardar datos en localStorage para uso offline</li>
    <li><strong>Actualización de UI:</strong> Renderizar datos en la interfaz de usuario</li>
</ol>

<h3>Location Detection</h3>
<p><strong>Propósito:</strong> Detectar y validar la ubicación del usuario</p>
<p><strong>Pasos del flujo:</strong></p>
<ol>
    <li><strong>Solicitud de permisos:</strong> Pedir acceso a la geolocalización del navegador</li>
    <li><strong>Manejo de denegación:</strong> Ofrecer entrada manual de ubicación si se deniegan permisos</li>
    <li><strong>Obtención de coordenadas:</strong> Usar navigator.geolocation.getCurrentPosition()</li>
    <li><strong>Validación de precisión:</strong> Verificar que la precisión de ubicación sea aceptable</li>
    <li><strong>Conversión a formato usable:</strong> Extraer latitud y longitud para uso en APIs</li>
    <li><strong>Almacenamiento persistente:</strong> Guardar ubicación en localStorage para futuras sesiones</li>
</ol>

<h3>Temperature Conversion</h3>
<p><strong>Propósito:</strong> Convertir entre unidades de temperatura (Celsius/Fahrenheit)</p>
<p><strong>Pasos del flujo:</strong></p>
<ol>
    <li><strong>Detección de preferencia:</strong> Leer configuración de usuario desde localStorage</li>
    <li><strong>Conversión matemática:</strong> Aplicar fórmulas de conversión según la unidad objetivo</li>
    <li><strong>Redondeo:</strong> Aplicar formato numérico consistente (generalmente un decimal)</li>
    <li><strong>Actualización en tiempo real:</strong> Re-renderizar todos los elementos de temperatura</li>
    <li><strong>Persistencia de preferencia:</strong> Guardar la unidad seleccionada para futuras sesiones</li>
</ol>

<h3>Offline Caching</h3>
<p><strong>Propósito:</strong> Permitir funcionalidad básica sin conexión a internet</p>
<p><strong>Pasos del flujo:</strong></p>
<ol>
    <li><strong>Registro del Service Worker:</strong> Durante la instalación de la aplicación</li>
    <li><strong>Pre-caching de recursos:</strong> Almacenar archivos estáticos esenciales</li>
    <li><strong>Cache-first strategy:</strong> Servir desde caché cuando esté disponible</li>
    <li><strong>Actualización en background:</strong> Buscar nuevas versiones cuando haya conexión</li>
    <li><strong>Manejo de datos meteorológicos:</strong> Usar datos cacheados cuando la API no responda</li>
    <li><strong>Notificación de estado:</strong> Informar al usuario cuando esté en modo offline</li>
</ol>

<h2>8.2. Componentes Clave Involucrados</h2>

<h3>Scripts/API.js</h3>
<p><strong>Responsabilidad:</strong> Manejar todas las comunicaciones con APIs externas de meteorología</p>
<p><strong>Métodos principales:</strong></p>
<ul>
    <li><strong>getWeatherData(lat, lon):</strong> Obtiene datos meteorológicos para coordenadas específicas</li>
    <li><strong>handleApiErrors(response):</strong> Maneja errores HTTP y de red de manera uniforme</li>
    <li><strong>constructApiUrl(coordinates):</strong> Construye URLs válidas para la API meteorológica</li>
</ul>

<h3>Scripts/Location.js</h3>
<p><strong>Responsabilidad:</strong> Gestionar la detección y almacenamiento de ubicación</p>
<p><strong>Métodos principales:</strong></p>
<ul>
    <li><strong>getUserLocation():</strong> Solicita y obtiene la ubicación del usuario</li>
    <li><strong>requestLocationPermission():</strong> Maneja la solicitud de permisos de geolocalización</li>
    <li><strong>saveLocationToStorage(coords):</strong> Almacena ubicación en localStorage</li>
    <li><strong>getStoredLocation():</strong> Recupera ubicación previamente guardada</li>
</ul>

<h3>Scripts/Forecast.js</h3>
<p><strong>Responsabilidad:</strong> Procesar y mostrar pronósticos meteorológicos</p>
<p><strong>Métodos principales:</strong></p>
<ul>
    <li><strong>displayCurrentWeather(data):</strong> Renderiza condiciones meteorológicas actuales</li>
    <li><strong>displayForecast(data):</strong> Muestra pronóstico extendido</li>
    <li><strong>updateWeatherIcons(condition):</strong> Cambia iconos según condiciones meteorológicas</li>
</ul>

<h3>Scripts/Menu.js</h3>
<p><strong>Responsabilidad:</strong> Gestionar la navegación y configuración de la aplicación</p>
<p><strong>Métodos principales:</strong></p>
<ul>
    <li><strong>toggleMenu():</strong> Abre/cierra el menú de navegación</li>
    <li><strong>handleSettingsChange():</strong> Maneja cambios en configuraciones de usuario</li>
    <li><strong>navigateTo(page):</strong> Cambia entre páginas de la aplicación</li>
</ul>

<h3>Service Worker</h3>
<p><strong>Responsabilidad:</strong> Gestionar caching offline y funcionalidad PWA</p>
<p><strong>Funcionalidades clave:</strong></p>
<ul>
    <li><strong>Caching de recursos estáticos:</strong> HTML, CSS, JS, imágenes</li>
    <li><strong>Estrategia cache-first:</strong> Prioriza contenido cacheados</li>
    <li><strong>Background sync:</strong> Sincronización cuando recupera conexión</li>
</ul>

<h2>8.3. Explicación del Patrón de Diseño Identificado</h2>

<h3>Patrón: Service-Oriented Architecture con Separation of Concerns</h3>

<p><strong>Identificación del patrón:</strong> Basado en la estructura modular de scripts separados por responsabilidades específicas, uso de servicios especializados y clara separación entre lógica de presentación, datos y servicios externos.</p>

<p><strong>Componentes principales del patrón:</strong></p>

<h4>1. Servicios (Service Layer)</h4>
<p><strong>Responsabilidad:</strong> Gestionar operaciones de negocio y comunicaciones externas</p>
<p><strong>Componentes:</strong></p>
<ul>
    <li><strong>API Service (api.js):</strong> Maneja todas las comunicaciones con APIs externas</li>
    <li><strong>Location Service (location.js):</strong> Gestiona detección y almacenamiento de ubicación</li>
    <li><strong>Cache Service (Service Worker):</strong> Maneja almacenamiento offline y caching</li>
</ul>

<pre><code>// Ejemplo de interacción entre servicios
async function fetchWeatherData() {
    try {
        // Location Service obtiene coordenadas
        const coords = await LocationService.getUserLocation();
        
        // API Service obtiene datos meteorológicos
        const weatherData = await ApiService.getWeatherData(coords.lat, coords.lon);
        
        // Forecast Service procesa y muestra datos
        ForecastService.displayCurrentWeather(weatherData);
        
        // Cache Service almacena datos para offline
        CacheService.storeWeatherData(weatherData);
    } catch (error) {
        ErrorHandler.handleWeatherError(error);
    }
}
</code></pre>

<h4>2. Componentes de Presentación (View Layer)</h4>
<p><strong>Responsabilidad:</strong> Gestionar la interfaz de usuario y interacción del usuario</p>
<p><strong>Componentes:</strong></p>
<ul>
    <li><strong>Forecast Component (forecast.js):</strong> Renderiza datos meteorológicos</li>
    <li><strong>Menu Component (menu.js):</strong> Gestiona navegación y configuración</li>
    <li><strong>Templates HTML:</strong> Define estructura de las vistas</li>
</ul>

<h4>3. Gestión de Estado (State Management)</h4>
<p><strong>Responsabilidad:</strong> Mantener y sincronizar el estado de la aplicación</p>
<p><strong>Implementación:</strong> Combinación de localStorage para persistencia y variables en memoria para estado temporal</p>

<pre><code>// Ejemplo de gestión de estado para unidades de temperatura
class TemperatureState {
    constructor() {
        this.unit = localStorage.getItem('tempUnit') || 'celsius';
    }
    
    setUnit(unit) {
        this.unit = unit;
        localStorage.setItem('tempUnit', unit);
        this.notifyObservers();
    }
    
    convertTemperature(tempCelsius) {
        return this.unit === 'fahrenheit' ? 
            (tempCelsius * 9/5) + 32 : tempCelsius;
    }
}
</code></pre>

<h4>4. Patrones de Comunicación Identificados</h4>
<ul>
    <li><strong>Observer Pattern:</strong> Para notificar cambios de estado a componentes afectados</li>
    <li><strong>Singleton Pattern:</strong> Servicios principales son instanciados una sola vez</li>
    <li><strong>Strategy Pattern:</strong> Diferentes estrategias para fetching de datos (online/offline)</li>
</ul>

<h4>5. Ventajas de esta arquitectura</h4>
<ul>
    <li><strong>Alta cohesión:</strong> Cada servicio tiene una responsabilidad única y bien definida</li>
    <li><strong>Bajo acoplamiento:</strong> Los servicios se comunican through well-defined interfaces</li>
    <li><strong>Testabilidad:</strong> Fácil de testear servicios individualmente</li>
    <li><strong>Escalabilidad:</strong> Fácil agregar nuevos servicios o modificar existentes</li>
    <li><strong>Mantenibilidad:</strong> Código organizado y fácil de entender</li>
</ul>

<h4>6. Flujo de datos típico</h4>
<pre><code>Usuario → Evento UI → Menu Service → Llamada a API Service → 
Procesamiento → Forecast Service → Actualización UI → 
Cache Service (opcional)
</code></pre>

<p><strong>Conclusión:</strong> La aplicación utiliza una arquitectura orientada a servicios con separación clara de responsabilidades, donde cada módulo JavaScript actúa como un servicio especializado que colabora con otros a través de interfaces bien definidas, facilitando el mantenimiento, testing y escalabilidad del código.</p>